---
title: "Generando Insights: Análisis de la Demanda de Reservaciones en Hoteles"
subtitle: "Proyecto de Discovery"
author: "Alejandro Rojas Moreno"
date: "8/2/2021"
output:
  html_document:
    code_folding: show
    code_download: true
    df_print: paged
    theme: spacelab
    toc: true
    toc_float: true
editor_options:
  chunk_output_type: console
---

&nbsp;

# <span style="color:rgb(0, 0, 205)">Presentación</span>

<div class=text-justify>
En la presente publicación se expondrá un proyecto de **Discovery**. Este tipo de proyectos van más enfocados al análisis descriptivo y exploratorio, es decir, a analizar la data para encontrar tendencias, patrones y anomalías (si es que las hay) que ayuden a generar insights al negocio y así poder contribuir a que se tomen mejores decisiones. Ahora, lo anterior, no significa que no se pueda complementar con un análisis más avanzado como, por ejemplo, un modelo de machine learning, incluso, desde mi punto de vista, previo a la creación de un modelo analítico avanzado es altamente recomendable, primero, hacer un análisis de discovery, ya que esto permitirá tener un acercamiento y entendimiento al giro del negocio. En resumen, este proyecto será un trabajo de **data mining**.
</div>

# <span style="color:rgb(0, 0, 205)">Contexto</span>

<div class=text-justify>
El análisis se hará a la demanda de reservaciones de dos hoteles ubicados en Lisboa, Portugal. Un **hotel resort** y el otro un **hotel en ciudad**. Dicha información abarca el periodo comprendido entre el 1 de julio de 2015 al 31 de agosto de 2017. Por razones de seguridad y de confidencialidad, se han omitido los datos de identificación tanto de los hoteles como de los clientes.

Supongamos, para fines didácticos, que se nos ha encargado hacer un análisis con la información antes mencionada para encontrar insights que ayuden a mejorar la toma de decisiones así como a la identificación de diferencias o similitudes (si las hay) entre ambos hoteles con el propósito de elaborar estrategias de marketing diferenciadas. Todo lo anteior, para lograr incrementar la rentabilidad del negocio.
</div>

Por tanto, los objetivos del proyecto serán:

1. Identificar y entender el patrón de consumo de los clientes.
2. Determinar las posibles diferencias entre las demandas en ambos hoteles.
3. Localizar insights de interés que puedan ayudar a hacer crecer el negocio.

# <span style="color:rgb(0, 0, 205)">Set up</span>

Iniciamos configurando las opciones generales que vamos a requerir para el desarrollo de este proyecto..

```{r setup, message=FALSE, comment="", warning=FALSE, results='hide'}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = "center",
                      out.width = "90%",
                      out.height = "70%")

paquetes <- c('tidyverse',    # manipulación datos
              'lubridate',    # manejar fechas
              'knitr',        # manejo de tablas
              'kableExtra',   # manejo de tablas
              'plotly',       # gráficos interactivos
              'DT',           # visualizción de tablas
              'gridExtra',    # layout de graficos ggplot
              'nortest',      # pruebas estadísticas
              "summarytools", # estadísticas univariantes
              "sfo")          # grafica sankey

instalados <- paquetes %in% installed.packages()

if(sum(instalados == FALSE) > 0) {
  install.packages(paquetes[!instalados])
}

lapply(paquetes, require, character.only = TRUE)

```

&nbsp;

# <span style="color:rgb(0, 0, 205)">Datos</span>

La información para este análisis es pública y los datos así como su descripción se encuentran en la página de [ScienceDirect](https://www.sciencedirect.com/science/article/pii/S2352340918315191). También, se encuentran en mi repositorio de [github](https://github.com/arojasmor/Hoteles).

Ambos hoteles comparten la misma estructura de datos contenida en 32 variables, el hotel resort tiene 40,060 observaciones y el hotel de ciudad 79,330 observaciones. Cada registro representa una reservación.

```{r variables}
df <- read.csv("hoteles.csv")

table(df$hotel) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>%
  kable_paper("hover", full_width = F)
```

La descripción de las variables es la siguiente:

```{r}
t1 <- read.csv("variables.csv")

DT::datatable(t1,
                    extensions = 'FixedColumns',
                    rownames = FALSE,
                    filter = 'top',
                    options = list(
                      pageLength = 5,
                      autoWidth = TRUE,
                      columnDefs = 
                        list(list(width = '300px')),
                      scrollX = TRUE,
                      escape = T)
              )
```

&nbsp;

# <span style="color:rgb(0, 0, 205)">Análisis Exploratorio</span>

## <span style="color:rgb(0, 0, 205)">Tipos de variables</span>

Hechemos un primer vistazo a la estructura de las variables para identificar si tienen los tipos correctos o de lo contrario cambiarlos.

```{r EDA1}
glimpse(df)

```

&nbsp;

<div class=text-justify>
Con este primer resumen  vemos que hay variables a las que tenemos que cambiarles el tipo como, por ejemplo, la variable hotel, que está como character y es recomendable pasarla a tipo factor, sobre todo para que se nos facilite la creación de gráficos, además, hay algoritmos que necesitan que las variables categóricas estén como factores y aunque en este trabajo no se utilizará ningún algoritmo es bueno tenerlo presente (al menos si se está trabajando con R, pues en Python no se tiene ese detalle ya que no existe el tipo factor).
</div>

También, vemos a primera vista que hay valores NULL en las variables agent y company.

&nbsp;

## <span style="color:rgb(0, 0, 205)">Valores NA y NULL</span>

<div class=text-justify>
Ahora, antes de hacer alguna modificación a los tipos es altamente recomendable conocer la cardinalidad de las variables categóricas con el objetivo de identificar desde el inicio del proyecto los posibles datos raros o extraños como espacios o caracteres especiales. Para esto nos apoyaremos de tablas de frecuencias:
</div>

```{r EDA2}
df2 <- df %>% select_if(is.character)

  for(i in 1:length(df2)){
  table(df2[i])
  print(table(df2[i]))
  }

```

Es mucha información en esta salida, sin embargo, podemos identificar:

* una variable con 488 valores NULL
* una segunda variable con 16,340 valores NULL
* una tercer variable tiene 112,593 valores NULL

Veamos otro resumen diferente que nos permitirá identificar las variables con valores NA:

```{r EDA3}
map_dbl(df, .f = function(x){sum(is.na(x))})
```

En esta otra vista se puede ver que hay 4 valores perdidos solo en la variable children.

Identifiquemos cuáles son las variables en donde hay valores NULL:

```{r EDA4}
nulls <- function(variable) {
  sum(if_else(variable == 'NULL', 1, 0))
}

df %>% 
  mutate_all(as.character) %>% 
  lapply(., nulls)
```

Hemos identificado que en las variables country, agent y company hay valores NULL.

Después de haber realizado un primer análisis exploratorio lo que debemos hacer es:

* Cambiar algunos tipos de datos de character a factor.
* Trabajar con los datos NA de la variable children.
* Decidir qué hacer con las observaciones NULL de las tres variables que identificamos.

&nbsp;

## <span style="color:rgb(0, 0, 205)">Outliers y Cardinalidad</span>

<div class=text-justify>
En esta parte del análisis exploratorio empezaremos por revisar las variables categóricas o de tipo character. Aquí el objetivo es conocer cómo está conformada la cardinalidad en cada variable, ya que de haber pocas observaciones de una categoría será preferible modificarla y crear grupos.
</div>

Empecemos con el primer grupo de variables:

```{r grafica1}
df2 %>% 
  select(1:7) %>% 
  mutate(id = 1:nrow(.)) %>% 
  pivot_longer(-id, names_to = 'variable', values_to = 'valor') %>% 
  ggplot(aes(valor)) +
  geom_bar() +
  scale_y_continuous(labels = scales::comma) + 
  facet_wrap(~variable, scales = 'free', ncol = 2)

```

&nbsp;

Al observar las gráficas anteriores podemos determinar las siguientes acciones a seguir:

* Para la variable **distribution_channel**: juntar las dos o tres categorías más bajas en una
  sola.
* En la variable **market_segment**: revisar la frecuencia de los segmentos para agrupar en
  una sola categoría las que tienen muy baja cantidad de observaciones.
* Variable **resereved_room_type**: seguir la misma estratégia, juntar en una sola categoría
  las observaciones con menor frecuencia.
* Variable **country**: determinar cómo agrupar las observaciones que presentan mucha dispersión.
* Para la variable **meal**: igualmente, hacer un grupo con las categorías menos frecuentes.

Segundo grupo de variables tipo character:

```{r grafica2}
df2 %>% 
  select(8:14) %>% 
  mutate(id = 1:nrow(.)) %>% 
  pivot_longer(-id, names_to = 'variable', values_to = 'valor') %>% 
  ggplot(aes(valor)) +
  geom_bar() +
  scale_y_continuous(labels = scales::comma) + 
  facet_wrap(~variable, scales = 'free', ncol = 2)

```

&nbsp;

En esta segunda parte de variables categóricas, podemos concluir las siguientes acciones a seguir:

* En la variable **agent**: revisar la variable ya que parece que no hay mucha información.
* Variable **company**: eliminarla, ya que hay demasiados valores NULL (112,593 de 119,390).
* Para la variable **deposit_type**: juntar la categoría de menor frecuencia con la categoría
  Non Refund.
* **Assigned_room_type**: dejar las principales categorías y juntar el resto en otra.
* **Customer_type**: juntar todas las categorías en una sola excepto la de mayor frecuencia.
* **Reservation_staus**: dejar solo dos categorías pasando No-Show a Canceled.

&nbsp;

## <span style="color:rgb(0, 0, 205)">Variables discretas</span>

Ahora, veamos las variables de tipo discreto, o sea, las de tipo entero:

```{r grafica3, message=FALSE}
df3 <- df %>% select_if(is.integer)

df3 %>% 
  select(1:9) %>% 
  mutate(id = 1:nrow(.)) %>% 
  pivot_longer(-id, names_to = 'variable', values_to = 'valor') %>% 
  ggplot(aes(valor)) +
  geom_bar() +
  scale_y_continuous(labels = scales::comma) + 
  facet_wrap(vars(variable), scales = 'free',ncol = 2)

df3 %>% 
  select(10:17) %>% 
  mutate(id = 1:nrow(.)) %>% 
  pivot_longer(-id, names_to = 'variable', values_to = 'valor') %>% 
  ggplot(aes(valor)) +
  geom_bar() +
  scale_y_continuous(labels = scales::comma) + 
  facet_wrap(vars(variable), scales = 'free',ncol = 2)
```

&nbsp;

Al analizar visualmente esas variables podemos afirmar que también tenemos que hacer algunas transformaciones:

* Las siguientes variables pasarlas a tipo binarias, ya que por su alto desbalanceo conviene
  tenerlas en ese tipo: 
  - **babies**
  - **children**
  - **previous_cancelations**
  - **total_special_request**
  - **booking_changes**
  - **days_in_waiting_list**
  - **previous_bookings_not_canceled**
  - **required_car_parking_spaces**
* Revisar la variable **adults**: crear solo 3 categorías (1, 2 y más de 2).
* En la variable **stays_in_week_nights**: juntar las observaciones que sean más de 4.
* En **stays_in_weekend_nights**: por conveniencia, hacer dos categorías, 1 y más de 1.

&nbsp;

## <span style="color:rgb(0, 0, 205)">Variables continuas</span>

Finalmente, revisamos la única variable continua que tenemos, **adr**:

```{r grafica4}
df %>% 
  ggplot(aes(x = factor(1), y = adr)) +
  geom_boxplot(outlier.colour = "red") +
  scale_y_continuous(labels = scales::comma) + 
  labs(
    title = "adr"
  )

```

En el boxplot se aprecia claramente que hay un valor extremo, sin embargo, no sabemos su valor. En estos casos es recomendable hacer una tabla resumen con las principales medidas estadísticas:

```{r}
descr(df$adr, 
      style = "rmarkdown", 
      justify = "c",
      headings = T) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>%
  kable_paper("hover", full_width = F)

arrange(df,desc(adr)) %>% 
  select(adr) %>%
  head(10) %>%
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>%
  kable_paper("hover", full_width = F)
```

Con apoyo de las tablas resumen sabemos que es de 5,400. Es una sola observación la que está afectado a toda la variable. Aquí lo recomendable será:

* Eliminar la observacion extrema de 5,400.

&nbsp;

# <span style="color:rgb(0, 0, 205)">Transformación de datos</span>

A continuación, realizaremos las transformaciones que previamente identificamos en la etapa de exploración.

## <span style="color:rgb(0, 0, 205)">Cambiar el tipo de variables</span>

```{r}
# Se prepara el cambio

a_factor <- c('hotel','arrival_date_year','arrival_date_month','arrival_date_week_number',
              'arrival_date_day_of_month','meal','country','market_segment',
              'distribution_channel', 'reserved_room_type','assigned_room_type',
              'deposit_type','agent','company','customer_type','reservation_status')

a_logico <- c('is_canceled','is_repeated_guest')

a_discreto <- c('stays_in_weekend_nights','stays_in_week_nights','adults','children',
                'babies','previous_cancellations','previous_bookings_not_canceled',
                'booking_changes','days_in_waiting_list','required_car_parking_spaces',
                'total_of_special_requests')

# Hacemos el cambio

df <- df %>% 
  mutate_at(all_of(a_factor), as.factor) %>% 
  mutate_at(all_of(a_logico), as.logical) %>% 
  mutate_at(all_of(a_discreto), as.integer)

glimpse(df)
```

Ya tenemos todas las variables con el tipo correcto. La variable adr de origen viene bien y la variable reservation_status_date por el momento conviene tenerla como character (en ese tipo no ocupa mucho espacio en memoria).

&nbsp;

## <span style="color:rgb(0, 0, 205)">Tratamiento de valores NA y NULL</span>

<div class=text-justify>
Ya habíamos identificado que en la variable children hay 4 valores NA, por lo que, se procederá a imputarlos por el valor más frecuente (la moda). También, en la variable country se detectaron 488 valores NULL, por lo que, se seguirá la misma estratégia de imputación debido a que son relativamente pocos datos en relacion con el tamaño de la base de datos. En este paso, aprovecharemos para eliminar las variables agent y company, ya que tienen demasiados valores NULL y no conviene realizar algún tipo de imputación: 
</div>

```{r}
# se identifica el valor más frecuente

count(df, children, sort = T) %>% # children
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>%
  kable_paper("hover", full_width = F)

count(df, country, sort = T) %>% head(10) %>% # country
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>%
  kable_paper("hover", full_width = F)
```

Se eliminan las variables agent y company. Se imputan los valores NA y NULL.

```{r}
df <- df %>% 
  select(-agent, -company) %>% # se eliminan esas variables
  mutate(children = ifelse(is.na(children), 0, children), # se sustituyen NA por 0
         country = fct_recode(country, 'PRT' = 'NULL') # se sustituyenn NULL por PRT
  )
```

&nbsp;

## <span style="color:rgb(0, 0, 205)">Outlier y discretización</span>

Como solo se identificó una observacion exrema (5,400), se procederá a eliminarla del dataset:

```{r}
df <- df %>% 
  filter(adr != 5400)
```

Las acciones para recodificar algunas variables serán:

- En country dejar los 15 primeros mercados y juntar el resto en la categoría OTROS
- En market_segment unir Undefined, Aviation, Complementary en el grupo Corporate
- En assigned_room_type y reserved_room_type dejar A y D juntar el resto
- En customer_type agrupar para dejar solo las categorías Transient y OTROS
- En distribution_channel juntar Corporate, GDS y Undefined en Corporate
- En reservation_status agrupar las observaciones de No-Show con Canceled
- En meal recodificar entre BB y OTROS
- En desposit_type juntar Non Refund con Refundable y llamarlo Deposit

```{r}
df <- df %>%
  #Recodificar
  mutate(
         country = fct_lump(country, n = 15, other_level = 'OTROS'),
         market_segment = fct_collapse(market_segment,
                                       'Corporate' = c('Corporate','Undefined','Aviation','Complementary')),
         distribution_channel = fct_collapse(distribution_channel,
                                       'Corporate' = c('Corporate','Undefined','GDS')),
         reservation_status = fct_collapse(reservation_status,
                                       'Canceled' = c('Canceled','No-Show')),
         deposit_type = fct_collapse(deposit_type,
                                       'Deposit' = c('Non Refund','Refundable')),
         assigned_room_type = fct_collapse(assigned_room_type,
                                           'A' = 'A',
                                           'D' = 'D',
                                           other_level = 'OTROS'),
         reserved_room_type = fct_collapse(reserved_room_type,
                                           'A' = 'A',
                                           'D' = 'D',
                                           other_level = 'OTROS'),
         customer_type = fct_collapse(customer_type,
                                           'Transient' = 'Transient',
                                           other_level = 'OTROS'),
         meal = fct_collapse(meal,
                                  'BB' = 'BB',
                                  other_level = 'OTROS'))
```

Ahora, lo siguiente es discretizar las tres variables que por su distribución tan dispersa es mejor modificarlas:

- Convertir adults a 1, 2 y mas de 2
- En stays_in_week_nights juntar en 1, 2, 3, 4 y mas de 4
- En stays_in_weekend_nights juntar en 1 y más de 1

```{r}
df <- df %>%
  mutate(
         adults = as.factor(case_when(adults <= 1 ~ '01_Uno',
                            adults == 2 ~ '02_Dos',
                            adults > 2 ~ '03_Mas_de_Dos',
                            TRUE ~ '99_ERROR')),
         stays_in_week_nights_disc = as.factor(case_when(stays_in_week_nights <= 1 ~ '01_Uno',
                            stays_in_week_nights == 2 ~ '02_Dos',
                            stays_in_week_nights == 3 ~ '03_Tres',
                            stays_in_week_nights == 4 ~ '04_Cuatro',
                            stays_in_week_nights > 4 ~ '05_Mas_de_Cuatro',
                            TRUE ~ '99_ERROR')),
         stays_in_weekend_nights_disc = as.factor(case_when(stays_in_weekend_nights <= 1 ~ '01_Uno',
                            stays_in_weekend_nights > 1 ~ '02_Mas_de_Uno',
                            TRUE ~ '99_ERROR')),
        
         )
```

Por último, crear variables binarias para las siguientes variables:

- babies
- booking_changes
- children
- previous_cancelations
- required_car_parking_spaces
- total_special_request
- days_in_waiting_list
- previous_bookings_not_canceled

```{r}
df <- df %>%
  mutate(
         babies = as.logical(ifelse(babies == 0, 0, 1)),
         booking_changes = as.logical(ifelse(booking_changes == 0, 0, 1)),
         children = as.logical(ifelse(children == 0, 0, 1)),
         previous_cancellations = as.logical(ifelse(previous_cancellations == 0, 0, 1)),
         required_car_parking_spaces = as.logical(ifelse(required_car_parking_spaces == 0, 0, 1)),
         total_of_special_requests = as.logical(ifelse(total_of_special_requests == 0, 0, 1)),
         days_in_waiting_list = as.logical(ifelse(days_in_waiting_list == 0, 0, 1)),
         previous_bookings_not_canceled = as.logical(ifelse(previous_bookings_not_canceled == 0, 0, 1))
         )
```

Una vez que hemos realizado todas las transformaciones que identificamos en la parte del análisis exploratorio, Volvemos a hacer los gráficos para comprobar los resultados deseados.

Variables de tipo factor:

```{r}
# primer bloque de variables

df %>% 
  select_if(is.factor) %>%
  select(1:9) %>% 
  mutate(id = 1:nrow(.)) %>% 
  pivot_longer(-id, names_to = 'variable', values_to = 'valor') %>% 
  ggplot(aes(valor)) +
  geom_bar() +
  scale_y_continuous(labels = scales::comma) + 
  facet_wrap(vars(variable), scales = 'free', ncol = 3)

# segundo bloque de variables

df %>% 
  select_if(is.factor) %>%
  select(10:17) %>% 
  mutate(id = 1:nrow(.)) %>% 
  pivot_longer(-id, names_to = 'variable', values_to = 'valor') %>% 
  ggplot(aes(valor)) +
  geom_bar() +
  scale_y_continuous(labels = scales::comma) + 
  facet_wrap(vars(variable), scales = 'free', ncol = 3)
```

Variables binarias o lógicas:

```{r}
df %>% 
  select_if(is.logical) %>% 
  mutate(id = 1:nrow(.)) %>% 
  pivot_longer(-id, names_to = 'variable', values_to = 'valor') %>% 
  ggplot(aes(valor)) +
  geom_bar() +
  scale_y_continuous(labels = scales::comma) + 
  facet_wrap(vars(variable), scales = 'free',ncol = 2)
```

Variable continua:

```{r}
df %>% 
  ggplot(aes(x = factor(1), y = adr)) +
  geom_boxplot(outlier.color = "red") +
  labs(
    title = "adr"
  )


descr(df$adr, 
      style = "rmarkdown", 
      justify = "center",
      headings = T) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>%
  kable_paper("hover", full_width = F)

```

<div class=text-justify>
En las gráficas actualizadas, ya podemos apreciar mejor las distribuciones de las variables, pues no hay asimetrías fuertes ni desbalances severos en las variables de tipo factor. Las variables binarias o lógicas se ven bien y la única variable continua aunque presenta valores atípicos ya no hay presencia de valores extremos enmascarados. 
</div>

&nbsp;

# <span style="color:rgb(0, 0, 205)">Creación de variables sintéticas</span>

<div class=text-justify>
Una de las partes más interesantes en cualquier proyecto de discovery es el de crear variables nuevas a partir de las variables originales, las cuales son comúnmente llamadas variables sintéticas. Estas variables deben de crearse con un sentido de negocio. A continuación, crearemos algunas variables que nos servirán para la etapa de discovery.

En la base de datos no viene una fecha de llegada como tal, o sea, compuesta por el día, mes y año, sin embargo, si tenemos cada componente por separado, por lo que, vamos a crearla.

Ademas, tenemos información sobre el número de personas adultas, niños y bebés, por tanto, podemos crear una variable que nos indique el tipo de familia que se ha hospedado. 

Podemos incluir otra variable para saber si la persona es extranjera o nacional, entendiendo que nacional correspondería a los clientes de nacionalidad portuguesa.

Una tercera variable que nos sería de utilidad es el cambio de habitación, que la obtendremos de la diferencia entre el tipo de cuarto reservado y el tipo de cuarto asignado. 

Tambien, puede ser de utilidad conocer las noches totales que las personas se quedaron en algún hotel, conformadas por la suma de las noches entre semana más las noches en fin de semana.

Finalmente, una variable que sorprende que no venga en la base es la facturación total, por lo que, la crearemos.

En resumen, lo que haremos será crear las siguientes variables:

- **fecha_llegada**: a partir de arrival_date_year, arrival_date_month y arrival_date_day_of_month
- **familia**: a partir de adults, children y babies
- **extranjero**: 0 si es de Portugal y 1 si no lo es
- **cambio_habit**: si el valor de reserved_room_type es diferente al de assigned_room_type
- **noches_totales**: suma de stays_in_weekend_nights más stays_in_week_nights
- **facturacion_reserva**: lo que se ha facturado en esa reservación como resultado de multiplicar la variable creada noches_totales por adr
</div>

```{r}
df <- df %>% 
  mutate(fecha_llegada = as_date(paste(arrival_date_year,
                                       arrival_date_month,
                                       arrival_date_day_of_month,
                               sep = '/')),
         familia = case_when(
           adults == '01_Uno' & children + babies == 0 ~ '01_Soltero',
           adults == '01_Uno' & children + babies > 0 ~ '02_Monoparental',
           adults == '02_Dos' & children + babies == 0 ~ '03_Pareja_Sin_Hijos',
           adults == '02_Dos' & children + babies > 0 ~ '04_Pareja_Con_Hijos',
           adults == '03_Mas_de_Dos' & children + babies == 0 ~ '05_Grupo_Amigos',
           adults == '03_Mas_de_Dos' & children + babies > 0 ~ '06_Grupo_Amigos_Con_Hijos',
           TRUE ~ '99_ERROR'),
         extranjero = ifelse(country == 'PRT', 0, 1),
         cambio_habit = ifelse(reserved_room_type == assigned_room_type, 0, 1),
         noches_totales = stays_in_weekend_nights + stays_in_week_nights,
         facturacion_reserva = noches_totales * adr
         )
```

&nbsp;

# <span style="color:rgb(0, 0, 205)">Discovery y Generación de Insights</span>

En esta etapa es donde vamos a hacer propiamente el análisis del negocio, pues ya tenemos la data limpia y transformada. Es importante tener presente el tipo de giro o sector, ya que de eso dependerá los insights a buscar.

### <span style="color:rgb(0, 0, 205)">Estacionalidad</span>

<div class=text-justify>
Para el sector hotelero y, en general, el turismo, el identificar las llamadas temporadas altas y bajas es muy importante, ya que eso les permitirá prepararse, por ejemplo, para la llegada de masiva de personas (temporada alta) y/o hacer remodelaciones o ampliaciones a su infraestructura (temporada baja).

Técnicamente, para poder determinar si una serie presenta estacionalidad, entendida ésta como tendencias o patrones que se repiten constantemente dentro de un periodo de tiempo, es necesario al memos cuatro años de historia, sin embargo, como no contamos con tanta historia solo nos enfocaremos en el único periodo completo que tenemos, año 2016.
</div>

Veamos la tendencia del año 2016 en general, para ambos hoteles:

```{r}
df %>% 
  filter(arrival_date_year == '2016') %>% 
  ggplot(aes(fecha_llegada)) + 
  geom_density(size = 2, color = 'grey') + 
  theme(axis.text.x = element_text(angle = 90, size = 10)) +
    labs(title = "Llegadas 2016")
```

Al ver la gráfica podemos apreciar que al inicio y al final del año la demanda es baja, pero  al inicio del tercer trimestre la demanda es la más alta. Complementemos el análisis visual con una tabla resumen:

```{r}
df %>% 
  mutate(reservaciones = rep(1, nrow(df))) %>% # se crea la variable reservaciones
  filter(arrival_date_year == 2016) %>%        # se filtra por el año 2016
  group_by(arrival_date_month) %>%             # agrupamos por el mes de llegada
  summarise(reservaciones = n()) %>%           # contamos el número de reservaciones
  arrange(desc(-reservaciones)) %>%            # ordenamos de menor a mayor
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>%
  kable_paper("hover", full_width = F)      # acomodamos la salida en una tabla 
```

Ya con esta otra vista podemos concluir lo siguiente:

- En los meses de mayo y octubre hay mayor demanda de reservaciones.
- Enero, febrero y diciembre son los meses de menor demanda.
- Sorprende Julio y Agosto que son relativamente bajos.

Ahora, veamos la tendencia por tipo de hotel:

```{r}
df %>% 
  filter(arrival_date_year == '2016') %>% 
  ggplot(aes(fecha_llegada, color = hotel)) + 
  scale_color_manual(values = c("steelblue", "grey50"))+
  geom_density(size = 2) + 
  theme(axis.text.x = element_text(angle = 90, size = 10)) +
  labs(title = "Llegadas 2016 por tipo de Hotel")
```

De la gráfica anterior podemos ver que:

- Mantienen curvas de demanda parecidas.
- El hotel resort tiene ligeramente más demanda hasta la primavera.
- Mientras que el de ciudad destaca en Junio, Septiembre y Octubre

Hagamos una tabla para comparar los datos:

```{r message=FALSE}
df %>% 
  mutate(reservaciones = rep(1, nrow(df))) %>% # se crea la variable reservaciones
  filter(arrival_date_year == 2016) %>%        # se filtra por el año 2016
  group_by(arrival_date_month, hotel) %>%      # se agrupa por el mes de arrivo y hotel
  summarise(reservaciones = n()) %>%           # se hace conteo de reservaciones
  arrange(desc(-reservaciones)) %>%            # se ordena de menor a mayor
  pivot_wider(names_from = hotel, values_from = reservaciones) %>% # se pasa a formato ancho
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>% 
  kable_paper("hover", full_width = F) # salida en forma de tabla
```

&nbsp;

## <span style="color:rgb(0, 0, 205)">Análisis de facturación</span>

Para poder analizar la facturación tenemos que trabajar sólo con las reservas que finalmente tuvieron check-out.

```{r message=FALSE}
df %>% 
  filter(reservation_status == 'Check-Out') %>% 
  group_by(arrival_date_year, hotel) %>% 
  summarise(facturacion = sum(facturacion_reserva)) %>% 
  ggplot(aes(x = arrival_date_year, y = facturacion, fill = hotel)) +
  scale_fill_manual(values = c("steelblue", "grey50")) +
  scale_y_continuous(labels = scales::comma) + 
  geom_col(position = 'dodge') +
  labs(title = "Facturación por Tipo de Hotel", y = "Facturación", x = "Año de Llegada")
```

En la gráfica podemos apreciar claramente que la facturación se ha ido incrementando cada año, ahora, hay que tener presente que solo el año 2016 está completo, sin embargo, vemos que el 2017 se ve bien, pues solo llega al mes de agosto y casi alcanza los niveles de 2016.

Este incremento pudo deberse a varios motivos como, por ejemplo:

* un incremento en el número de las reservaciones, hubo más clientes.
* aumentó el precio medio.
* crecimiento promedio de noches por reserva.

Con el apoyo de una tabla veamos si esos motivos explican el incremento en la facturación:

```{r message=FALSE}
df %>% 
  filter(reservation_status == 'Check-Out' & arrival_date_year %in% c('2015','2016')) %>% 
  group_by(hotel,arrival_date_year) %>% 
  summarise(
    num_reservas = n(),
    noches_por_reserva = mean(noches_totales),
    precio_noche = mean(adr)) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>% 
  kable_paper("hover", full_width = T)
```
&nbsp;

<div class=text-justify>
Ya con la tabla podemos concluir que, para el caso del hotel de ciudad, el incremento de su facturación se debió, principalmente, al aumento en el número de reservas (casi 3 veceses más) y, en segundo lugar, al aumento del precio promedio por noche. Para el caso del hotel resort, el incremento en su facturación es debido únicamente al aumento en el número de reservas, porque tanto el número de noches por reserva como el precio promedio por noche presentaron disminuciones.

Veamos cómo está conformada la facturación por segmento de mercado:
</div>

```{r message=FALSE}
df %>% 
  group_by(hotel, market_segment) %>% 
  summarise(facturacion_segmento = sum(facturacion_reserva)) %>% 
  group_by(hotel) %>% 
  mutate(facturacion_total = sum(facturacion_segmento),
         porc_facturacion_total = facturacion_segmento / facturacion_total * 100) %>%
  dplyr::select(-facturacion_total) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>% 
  kable_paper("hover", full_width = T)

```

&nbsp;

De la tabla anterior, podemos concluir que la mayor parte de la facturación en ambos hoteles viene por el lado del segmento Online y, por el contrario, el segmento que menos contribuye es el Corporate.

```{r}
t0 <- df %>% 
  group_by(hotel, market_segment) %>% 
  summarise(facturacion_segmento = sum(facturacion_reserva)) %>% 
  group_by(hotel) %>% 
  mutate(facturacion_total = sum(facturacion_segmento),
         porc_facturacion_total = facturacion_segmento / facturacion_total * 100) %>%
  dplyr::select(-facturacion_total, -porc_facturacion_total)

t0$hotel <- as.character(t0$hotel)
t0$market_segment <- as.character(t0$market_segment)

sankey_ly(x = t0, 
          cat_cols = c("hotel", "market_segment"), 
          num_col = "facturacion_segmento", 
          title = "Distribución de Ingresos por Segmento Según Tipo de Hotel") 

```

Ahora, analicemos la facturación por familia, para ver la contribución de cada segmento:

```{r message=FALSE}
df %>% 
  group_by(hotel, familia) %>% 
  summarise(facturacion_familia = sum(facturacion_reserva)) %>% 
  group_by(hotel) %>% 
  mutate(facturacion_total = sum(facturacion_familia),
         porc_facturacion_total = facturacion_familia / facturacion_total * 100) %>% 
  dplyr::select(-facturacion_total) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>% 
  kable_paper("hover", full_width = T)
```

&nbsp;

Claramente se aprecia en el cuadro anterior, que el segmento de parejas sin hijos es el que más contribuye a la facturación total en ambos hoteles.

```{r}
t2 <- df %>% 
  group_by(hotel, familia) %>% 
  summarise(facturacion_familia = sum(facturacion_reserva)) %>% 
  group_by(hotel) %>% 
  mutate(facturacion_total = sum(facturacion_familia),
         porc_facturacion_total = facturacion_familia / facturacion_total * 100) %>% 
  dplyr::select(-facturacion_total, -porc_facturacion_total)

t2$hotel <- as.character(t2$hotel)

sankey_ly(x = t2, 
          cat_cols = c("hotel", "familia"), 
          num_col = "facturacion_familia", 
          title = "Distribución de Ingresos por Familia Según Tipo de Hotel") 

```

## <span style="color:rgb(0, 0, 205)">Análisis del mercado y del cliente</span>

En cuanto a los clientes, como ambos hoteles se encuentran en Portugal suponemos que la mayoría son de ese mismo país, sin embargo, hagamos una tabla para ver la distribución entre clientes nacionales y extranjeros:

```{r message=FALSE}
count(df, hotel, extranjero) %>% 
  group_by(hotel) %>% 
  mutate(total_hotel = sum(n),
         porc_hotel = n / total_hotel * 100) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>% 
  kable_paper("hover", full_width = F)
```

&nbsp;

Al ver el cuadro anterior, sorprende identificar que la mayoría de los clientes son extranjeros en ambos hoteles, ademas, en el hotel de ciudad hay casi el doble de clientes que en el hotel resort y en éste último poco menos de la mitad son clientes nacionales.

Ahora, veamos el top 5 de clientes por nacionalidad para ver de qué países hay mayor presencia para ambos hoteles:

```{r message=FALSE}
count(df, hotel, country) %>% 
  group_by(hotel) %>% 
  mutate(total_hotel = sum(n),
         porc_hotel = n / total_hotel * 100) %>% 
  arrange(hotel, desc(porc_hotel)) %>% 
  top_n(5) %>% 
  dplyr::select(-total_hotel) %>% 
  kbl(align = "c", digits = 2 ,format.args = list(big.mark = ",")) %>% 
  kable_paper("hover", full_width = F)
```

&nbsp;

Como era de esperarse, por país, la mayoría de los clientes de esta cadena de hoteles son de Portugal. Sin embargo, en el hotel de ciudad son los franceses y alemanes los que le siguen, a diferencia del hotel resort donde son los británicos y españoles los que tienen mayor frecuencia después de los portugueses.

&nbsp;

## <span style="color:rgb(0, 0, 205)">Análisis de precios</span>

A continuación, echemos un vistazo al promedio de los precios por noche:

```{r message=FALSE}
df %>% 
  filter(arrival_date_year %in% c('2015','2016')) %>% 
  group_by(hotel, arrival_date_week_number) %>% 
  summarise(precio_medio = mean(adr)) %>%
  ggplot(aes(x = arrival_date_week_number, y = precio_medio, group = 1)) +
  geom_line(color = 'grey50') +
  geom_smooth(color = 'red') +
  theme(axis.text.x = element_text(size = 8)) +
  labs(title = "Tendencia de Precios: 2015-2016")
```

La gráfica nos muestra que, al inicio de cada año y al final, el precio promedio de las reservas tiene su menor nivel, lo cual coincide con las épocas de baja demanda. Son entre las semanas 29 a 35 donde el precio promedio alcanza sus niveles máximos que, igualmente, se corresponde con la temporada de alta demanda.

Por lo anterior, veamos si existe alguna correlación entre el precio promedio y la demanda de reservas.

&nbsp;

# <span style="color:rgb(0, 0, 205)">Correlación Reservas vs Precio Medio</span>

Vamos hacer un pequeño análisis estadístico de correlación, por lo que, debemos tener presente algunas consideraciones:

1. Conocer si las variables presentan distribución normal, ya que de eso dependerá el coeficiente de correlación a usar.
2. De acuerdo con el resultado del punto anterior, elegir el coeficiente de correlación que corresponda.
3. Hacer una prueba de significancia estadística para descartar una posible correlación debido al azar.

## <span style="color:rgb(0, 0, 205)">Normalidad</span>

Análisis visual:

```{r message=FALSE}
c <- df %>% 
  filter(arrival_date_year %in% c('2015', '2016')) %>% 
  group_by(hotel, arrival_date_week_number) %>% 
  summarise(num_reservas = n(),
            precio_medio = mean(adr)) %>% 
  select(num_reservas, precio_medio)


h1 <- ggplot(data = c, aes(x = num_reservas)) + geom_histogram(aes(y = ..density.., fill = ..count..)) + scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C") + stat_function(fun = dnorm, colour = "firebrick", args = list(mean = mean(c$num_reservas), sd = sd(c$num_reservas))) + ggtitle("Histograma Reservas") + theme_bw()

qq1 <- ggplot(c, aes(sample = num_reservas)) +
  stat_qq() +
  stat_qq_line() +
  labs(title = "Distribución de Reservas")

h2 <- ggplot(data = c, aes(x = precio_medio)) + geom_histogram(aes(y = ..density.., fill = ..count..)) + scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C") + stat_function(fun = dnorm, colour = "firebrick", args = list(mean = mean(c$precio_medio), sd = sd(c$precio_medio))) + ggtitle("Histograma Precio Medio") + theme_bw()

qq2 <- ggplot(c, aes(sample = precio_medio)) +
  stat_qq() +
  stat_qq_line() +
  labs(title = "Distribución de Precio Medio")


grid.arrange(h1, h2, qq1, qq2, nrow = 2, ncol = 2, top = "Análisis de Normalidad")
```

Al ver las gráficas podemos sospechar que ambas variables no presentan una distribución normal. Para poder confirmar lo anterior tenemos que hacer pruebas estadísticas. Ahora, como ambas series tienen más de 50 observaciones aplicaremos la prueba de normalidad de Lilliefors:

Pruebas de normalidad:

```{r}
lillie.test(x = c$num_reservas)

lillie.test(x = c$precio_medio)
```

Los resultados muestran que las dos series **no presentan una distribución normal**, ya que ambos p-value son menores al 0.05 de significancia. Por lo anterior, ya podemos decidir cuál coeficiente usar para conocer el grado de asociación entre ellas dadas las características de las series.

&nbsp;

## <span style="color:rgb(0, 0, 205)">Correlación</span>

Coeficiente de Correlación

Ya sabiendo que las series no presentan distribución normal, se usará el coeficiente de correlación de Spearman:

```{r}
cor(c$num_reservas, log(c$precio_medio), method = "spearman")
```

La correlación resulta ser positiva de 0.54, lo que nos indica un grado de asociación moderada, sin embargo, hay que hacer el test de significancia, para confirmar que realmente existe correlación entre el número de reservas y el precio medio, ya que de lo contrario dicha asociación puede deberse al azar.

```{r message=FALSE}
cor.test(x = c$num_reservas,
         y = log(c$precio_medio),
         alternative = "two.sided",
         conf.level = 0.95,
         method = "spearman")
```

El p-value es cercano a cero (menor a 0.05), por lo que, podemos afirmar que el coeficiente de correlación antes obtenido es significativo, o sea, la asociación entre las reservas y el precio medio no se da por casualidad.

Ya por último, calculemos el coeficiente de determinación para medir el tamaño del efecto:

```{r message=FALSE}
cor(c$num_reservas, log(c$precio_medio), method = "spearman")^2
```

El tamaño del efecto es mediano, cercano al 0.3. Veamos la relación visualmente:

```{r message=FALSE}
g <- c %>% 
  ggplot(aes(num_reservas, precio_medio)) +
  geom_point() +
  geom_smooth() +
  labs(title = "Relación Reservas vs Precio Promedio")

ggplotly(g)
```

Se aprecia que no hay una clara tendencia positiva o negativa, pues la nube de puntos casi se mantiene constante. Ahí hay una oportunidad de negocio.

veamos ahora por tipo de hotel y por semana durante el periodo de análisis:

```{r time, message=FALSE}
df4 <- df %>% 
  filter(reservation_status == 'Check-Out' & adr > 0)
  
df4 <- df4 %>%  
  group_by(arrival_date_year, hotel, arrival_date_week_number) %>% 
   summarise(num_reservas = n(),
             precio_medio = mean(adr)) %>% 
   select(arrival_date_year, num_reservas, precio_medio, arrival_date_week_number)

df4$arrival_date_week_number <- as.numeric(df4$arrival_date_week_number)

dfr <- df4 %>% 
  dplyr::filter(hotel == "Resort Hotel")

dfc <- df4 %>% 
  dplyr::filter(hotel == "City Hotel")


gr <- ggplot(dfr, aes(num_reservas, precio_medio)) +
  geom_jitter() +
  geom_point(aes(colour = arrival_date_week_number), size = 3) +
  labs(title = "Tendencia Semanal Hotel Resort: Precio Medio y Número de Reservaciones")

gc <- ggplot(dfc, aes(num_reservas, precio_medio)) +
  geom_jitter() +
  geom_point(aes(colour = arrival_date_week_number), size = 3) +
  labs(title = "Tendencia Semanal Hotel Ciudad: Precio Medio y Número de Reservaciones")

grid.arrange(gr, gc, nrow = 2, top = "Tendencias Semanales")

```

<div class=text-justify>
En las gráficas anteriores, el color de los puntos indica el tiempo (número de semana), entre más claro es el color más cercano al fin de año nos encontramos. Es en el hotel resort donde, en general, no se corresponde la temporada alta con precios promedio elevados, por lo que, sería conveniente analizar la posibilidad de aumentar los precios en temporada alta, o sea, buscar el precio óptimo en ese periodo del año.
</div>

Veamos la distribución de los precios por tipo de hotel:

```{r}
ggplot(df, aes(x = hotel, y = adr, color = hotel)) +
  geom_boxplot() +
  scale_color_manual(values = c("steelblue", "grey50")) +
  stat_summary(fun = mean, 
               geom = "point",
               shape = 20, 
               size = 4, 
               color = "red",
               fill = "red") +
  labs(title = "Precio Medio por Hotel")
```

Los precios medios en ambos tipos de hotel son muy parecidos, siendo en el hotel resort donde el 50% de los precios son más bajos.

```{r message=FALSE}
pm <- df %>% 
  group_by(hotel, lead_time) %>% 
  summarise(precio_medio = mean(adr))
  
gm <- pm %>% 
  ggplot(aes(x = lead_time, y = precio_medio, color = hotel)) +
  geom_point(alpha = 0.3, size = 1) +
  scale_color_manual(values = c("blue", "black")) +
  geom_smooth(se = F, size = 1) +
  geom_vline(xintercept = 180, colour = "red") +
  labs(title = "Tiempo de Espera")

ggplotly(gm)

```

Esta gráfica nos indica que reservando con más de 6 meses de anticipación se consiguen precios más bajos, sobre todo en el hotel resort. Hay dos observaciones con precios de cero, lo que probablemente se deba a error de origen o fueron promociones que se obsequiaron.

&nbsp;

# <span style="color:rgb(0, 0, 205)">Curva de Pareto</span>

<div class=text-justify>
A continuación, se graficará la curva de Pareto de la facturación. Recordando que la curva de pareto consiste en mostrar la regla de que, aproximadamente, el 20% de las observaciones analizadas generan el 80% de sus resultados. Esta regla no es fija y puede variar la distribución, sin embargo, es un buen indicador que permite conocer a los mejores clientes, los más rentables.

Entonces, hagamos una curva de pareto de la facturación por país para conocer la contribución de cada uno al negocio con las siguientes consideraciones: solo crearla para las reservaciones que no fueron canceladas y, también, sin considerar la categoría de OTROS que creamos anteriormente (por su nivel marginal de contribución de cada país que integran esa categoría).
</div>

```{r}
df %>% 
  filter(is_canceled == FALSE & country != "OTROS") %>% 
  group_by(country) %>% 
  summarise(total = sum(facturacion_reserva)) %>% 
  arrange(desc(total)) %>% 
  mutate(porc.acum.ventas = cumsum(total) / sum(total),
         ranking.ventas = row_number(desc(total))) %>% 
  dplyr::select(ranking.ventas, porc.acum.ventas) %>% 
  ggplot(aes(x = ranking.ventas, y = porc.acum.ventas)) +
  geom_line() +
  geom_vline(xintercept = 6, colour = "red") +
  geom_hline(yintercept = 0.79, colour = "red") +
  scale_x_continuous(breaks = c(1:15), labels = c("PRT", 
                                                  "GBR",
                                                  "FRA",
                                                  "ESP",
                                                  "DEU",
                                                  "IRL",
                                                  "ITA",
                                                  "BEL",
                                                  "NLD",
                                                  "CHE",
                                                  "USA",
                                                  "BRA",
                                                  "CN",
                                                  "AUT",
                                                  "SWE")) +
  ggplot2::annotate("text", 
           label = "80%-6",
           x = 5.5, y = 0.83,
           size = 3, 
           color = "navyblue") +
  labs(title = "Curva Pareto Facturación")

```

<div class=text-justify>
La gráfica nos muestra la contribución, a nivel de país, que tienen los clientes. Ahora, sin considerar a Portugal (por ser el país en donde se encuentran los hoteles), son solo 5 países los que contribuyen a generar casi el 80% de la facturación total: Gran Bretaña, Francia, España, Alemania e Irlanda. Sabiendo esto podemos recomentar focalizar promociones y/o campañas para los turistas de esas nacionalidades.
</div>

&nbsp;

# <span style="color:rgb(0, 0, 205)">Conclusiones</span>

<div class=text-justify>
Del análisis anterior, podemos señalar las siguentes conclusiones:

* Como toda empresa que pertenece al giro del turismo sus actividades presentan temporadas de alta y baja demanda, es decir, se ven afectadas por la estacionalidad propia de su sector. En el caso de los hoteles, se detectó estacionalidad (considerando solo el año 2016 por la falta de más información histórica).
* El hotel que más facturación tiene es el de ciudad, por lo que, si el objetivo es incrementar la facturación total de esta cadena de hoteles, se deben de enfocar los recursos en mejorar la facturación del hotel resort a través de campañas para lograr que el promedio de noches por reserva aumente así como analizar la posibilidad de incrementar los precios promedio sobre todo en temporada de alta demanda.
* La mayor parte de la facturación proviene del segmento Online en ambos tipos de hotel, en cambio, el segmento Corporate es el que menor contribuye.
* El mercado externo (sin considerar a Portugal), son diferentes, ya que mientras en el hotel de ciudad los franceses y alemanes son los clientes que más hacen reservas, en el hotel resort son los británicos y españoles los que más se hospedan.
* Se presenta estacionalidad en el precio de la reserva, pues es en el periodo comprendido entre las semanas 29 a 35 que los precios son más altos y menor en el resto del año.
</div>

&nbsp;

# <span style="color:rgb(0, 0, 205)">Insights</span>

<div class=text-justify>
* La temporada de alta demanda se presenta en los meses de mayo y octubre y, por el contrario, la temporada de menor demanda es en el periodo de diciembre a febrero.
* El hotel resort tiene un poco más de demanda hasta el primer trimestre del año mientras que en el hotel de ciudad la demanda es mayor en los meses de junio septiembre y octubre.
* Se podrían incrementar los precios en el hotel resort en temporada alta (inicio de año), ya que éstos se mantienen, en general, constantes. Se tendría que buscar un precio óptimo para ese periodo de tiempo.
* La mayor parte de la facturación proviene del segmento parejas sin hijos: en el hotel resort equivale al 70% y en el hotel de ciudad al 65%.
* Existe margen de maniobra para optimizar la política de precios, ya que las curvas de demanda tienen forma bimodal (dos picos durante el periodo de análisis) y, en cambio, la curva de precios solo presenta un pico. Lo anteior, recordando que la lógica de negocio indicaría que en época de alta demanda se pueden aumentar los precios buscando maximizar ganancias.
* Es en el hotel resort donde el periodo de alta demanda no se corresponde con precios promedio altos, por lo tanto, es en este hotel donde se tendría que arrancar un piloto de optimización de precios.
* A nivel de país y sin contar el mercado local (Portugal), son cinco países los que contribuyen a generar casi el 80% de la facturación total: Gran Bretaña, Francia, España, Alemania e Irlanda. 
</div>

